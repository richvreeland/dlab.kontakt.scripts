{	 __       ________ _     __
	|_ | ||\|/   |  | / \|\|(_
	|  |_|| |\__ | _|_\_/| |__)
}

function set_automation(var, text)
	{ add symbol prefix to show up first in DAW automation lists. }
	var->automation_name := "*" & TITLE & ": " & text
	var->automation_id := AUTOMATION_BASE_ID + automation_counter
	inc(automation_counter)
end function

function set_automation_arr(ui_id, labels)
	declare local i
	{ add symbol prefix to show up first in DAW automation lists. }
	for i := 0 to num_elements(labels) - 1
		set_control_par_arr(ui_id, CONTROL_PAR_AUTOMATION_ID, AUTOMATION_BASE_ID + automation_counter, i)
		set_control_par_str_arr(ui_id, CONTROL_PAR_AUTOMATION_NAME, "*" & labels[i], i)
		inc(automation_counter)
	end for
end function

function noteName(x) -> result
	result := !ROOT[x mod 12] & ((x/12)-2)
end function

function msg(txt)
	message(txt)
	status.dirty := 1
	status.timestamp := ENGINE_UPTIME - 1
end function

function play_note_and_propagate(note, vel, seek, duration) -> result
	result := play_note(note, vel, seek, duration)
	change_vol(result, EVENT_ID->volume, 0)
	change_tune(result, EVENT_ID->tune, 0)
	change_pan(result, EVENT_ID->pan, 0)
	change_velo(result, EVENT_ID->velocity)
end function

////////////////////////////////////////////////////////
//
//	Array Functions
//
////////////////////////////////////////////////////////

// Shift an array forward or backward by a certain amount.
function array_shift(array, by, startAt, endAt)
	declare ii
	declare outer
	declare temp
	if (by > 0)
		for outer := 0 to by - 1
			for ii := endAt downto startAt + 1
				temp        := array[ii-1]
				array[ii-1] := array[ii]
				array[ii]   := temp
			end for
		end for
	else
		for outer := 0 to abs(by) - 1
			for ii := startAt + 1 to endAt
				temp        := array[ii-1]
				array[ii-1] := array[ii]
				array[ii]   := temp
			end for
		end for
	end if
end function

// from Koala
// Reverse the order of an array
function array_reverse(arr, endAt)
	declare temp
	for _j := 0 to (endAt / 2)
		temp := arr[_j]
		arr[_j] := arr[endAt - _j ]
		arr[ endAt - _j ] := temp
	end for
end function

function array_shuffle(array, endAt)
	declare i
	declare j
	declare temp
	// While there are elements in the array
	for i := endAt downto 1
		// Pick a random index
		j := random(0, i);
		// And swap the last element with it
		temp := array[i]
		array[i] := array[j]
		array[j] := temp
	end for
end function

function array_shuffle_seeded(array, endAt, seed)
	declare i
	declare j
	declare temp
	// While there are elements in the array
	for i := endAt downto 1
		// Pick a random index
		j := randRangeA(0, i, seed)
		// And swap the last element with it
		temp := array[i]
		array[i] := array[j]
		array[j] := temp
	end for
end function

// given an array of numbers, will spit out a new array for the indices sorted by their associated value
function generate_sort_ascending_indices(steps, inArray, outArray)
	declare i
	declare temp_d
	declare temp_j
	declare j

	// initialize outArray with 0..steps-1
	for i := 0 to steps - 1
		outArray[i] := i
	end for

	for i := 1 to steps - 1

		j := i

		while(j > 0 and inArray[outArray[j - 1]] > inArray[outArray[j]])

			temp_j := outArray[j]

			// swap 'em'
			outArray[j] := outArray[j - 1]
			outArray[j - 1] := temp_j

			// carry on
			dec(j)
		end while
	end for
end function

{ insertion sort array and store the new index sequence, we'll go through in this order. }
function sort_table_in_new_arrays(steps, table, newArray, orderArray)

	declare i
	declare temp_d
	declare temp_j
	declare j

	for i := 0 to steps - 1
		newArray[i] := table[i]
		orderArray[i] := i
	end for

	for i := 1 to steps - 1

		j := i

		while(j > 0 and newArray[j - 1] > newArray[j])

			temp_d := newArray[j]
			temp_j := orderArray[j]

			{swap 'em'}
			newArray[j] := newArray[j - 1]
			newArray[j - 1] := temp_d

			orderArray[j] := orderArray[j - 1]
			orderArray[j - 1] := temp_j

			{carry on}
			dec(j)
		end while
	end for
end function

////////////////////////////////////////////////////////
//
//	UI Functions
//
////////////////////////////////////////////////////////

function move(name, x, y)
	if (x = 0 or y = 0)
		hide(name)
	else
		move_control(name, x, y)
		//move_control_px(name, (GRID_TO_PX_X * x) + PX_X_OFFSET, (GRID_TO_PX_Y * y) + PX_Y_OFFSET)
	end if
end function

function set_width(name, width)
	name->grid_width := width
	//name->width := GRID_TO_PX_X * width
end function

////////////////////////////////////////////////////////
//
//	Table Functions
//
////////////////////////////////////////////////////////

function table_increment(table, by, max, endAt)
	if (by < 0)
		table_decrement(table, abs(by), max, endAt)
	else if (by # 0)
		declare i
		if (max < 0)
			for i := 0 to endAt
				table[i] := modulo_range(table[i] + by, max, -max)
			end for
		else
			for i := 0 to endAt
				table[i] := (table[i] + by) mod max
			end for
		end if
	end if
end function

function table_decrement(table, by, max, endAt)
	declare i
	if (max < 0)
		for i := 0 to endAt
			table[i] := modulo_range(table[i] - by, max, -max)
		end for
	else
		for i := 0 to endAt
			table[i] := (table[i] + (max - by)) mod max
		end for
	end if
end function

function table_invert(table, maxValue, endAt)
	declare i
	if (maxValue < 0)
		for i := 0 to endAt
			table[i] := -table[i]
		end for
	else
		for i := 0 to endAt
			table[i] := maxValue - table[i]
		end for
	end if
end function

function table_is_zeroed(table, endAt) -> result
	declare i
	declare sum := 0
	for i := 0 to endAt
		sum := sum + abs(table[i])
	end for
	if (sum # 0)
		result := 0
	else
		result := 1
	end if
end function

function table_offset(table, xDelta, yDelta, tableMax, endAt)
	if (yDelta # 0)
		table_increment(table, yDelta, tableMax, endAt)
	end if
	if (xDelta # 0)
		array_shift(table, xDelta, 0, endAt)
	end if
end function

function table_ramp(table, tableMax, endAt)
	declare i
	declare l := tableMax + 0 // stupid
	declare r := -tableMax

	if (tableMax > 0)
		r := l
		l := 0
	end if

	for i:= 0 to endAt
		table[i] := lerpInt(l, r, real(i+1) / real(endAt+1))
	end for
end function

// if max is negative, assumes table.
function table_sine(table, tableMax, endAt)
	declare i
	declare ~add := 0.0
	declare ~coeff := real(-tableMax)

	if (tableMax > 0)
		add := 1.0
		coeff := real(tableMax) / 2.0
	end if

	for i:= 0 to endAt
		table[i] := round_to_int( (sin(lerp(0.0, 2.0 * NI_MATH_PI, real(i+1) / real(endAt+1))) + add) * coeff)
	end for
end function

function table_stripe(table, tableMax, endAt)
	declare i
	if (tableMax < 0)
		for i:= 0 to endAt
			table[i] := ((i mod 2)*-tableMax*2) + tableMax
		end for
	else
		for i:= 0 to endAt
			table[i] := (i mod 2) * tableMax
		end for
	end if
end function

function table_triangle(table, tableMax, endAt)
	declare i
	declare ~t := floor(real(endAt + 1)/2.0)
	declare midPoint := int(t)

	if (tableMax > 0)
		for i:= 0 to endAt
			if (i <= midPoint)
				table[i] := lerpInt(0, tableMax, real(i+1) / (t+1.0))
			else
				table[i] := lerpInt(tableMax, 0, real(i - midPoint) / (t+1.0))
			end if
		end for
	else
		for i:= 0 to endAt
			if (i <= midPoint)
				table[i] := lerpInt(tableMax, -tableMax, real(i) / t)
			else
				table[i] := lerpInt(-tableMax, tableMax, real(i - midPoint) / t)
			end if
		end for
	end if
end function

////////////////////////////////////////////////////////
//
//	Math Functions
//
////////////////////////////////////////////////////////

// curve is -50 to 50. Returns an alpha.
function curve(curveAmt, alpha) -> result
	declare ~exponent

	if (alpha = 0.0)
		result := 0.0
	else
		if (curveAmt < 0)
			exponent := map(real(curveAmt), -50.0, 0.0, 0.25, 1.0)
		else
			exponent := map(real(curveAmt), 0.0, 50.0, 1.0, 4.0)
		end if
		result := pow(alpha, exponent)
	end if
end function

// curve is -50 to 50. Returns a percentage
function curveInt(curveAmt, pct) -> result
	declare ~exponent
	declare ~tmp

	if (pct = 0)
		result := 0
	else
		if (curveAmt < 0)
			exponent := map(real(curveAmt), -50.0, 0.0, 0.25, 1.0)
		else
			exponent := map(real(curveAmt), 0.0, 50.0, 1.0, 4.0)
		end if
		tmp := 100.0 * pow(pct_to_alpha(pct), exponent)
		result := int(~tmp)
	end if
end function

// returns a 1 or a -1
function modulo_sign(n) -> result
	result := (((abs(n) mod 2) * 2) - 1)
end function

// modulo through a range
function modulo_range(x, min, max) -> result
	declare range := (1 + max) - min
	declare xNormal := (x-min)+(2*range)
	result := min + (xNormal mod range)
end function

function round_to_int(var) -> result
	result := int(round(var))
end function

function pct_to_alpha(var) -> result
	result := real(var) / 100.0
end function

// boundary inclusive
function rand_bi(max) -> result
	result := random(-abs(max), abs(max))
end function

function modifier_rand(offmax, ui_min, ui_max) -> result
	if (random(0, offmax) = 0)
		result := 0
	else
		result := random(ui_min, ui_max)
	end if
end function

function lerpInt(a, b, alpha) -> result
	result := int((real(a) * (1.0 - alpha)) + (real(b) * alpha))
end function

function lerp(a, b, alpha) -> result
	result := (a * (1.0 - alpha)) + (b * alpha)
end function

function millicents_to_semis(x) -> semis
	semis := real(x)/100000.0
end function

function cents_to_semis(cents) -> semis
	semis := real(cents)/100.0
end function

function millicents_to_pitch_ratio(millicents) -> pitch_ratio
	pitch_ratio := pow(2.0, real(millicents) / 1200000.0)
end function

// nightmare code but it works !
function randRangeB(min, max, seed) -> result
	result := int( (((sin(real(seed)) * 93456.0) - floor(sin(real(seed)) * 93456.0)) * real(max + 1 - min)) + real(min))
end function

// from Big Bob's library
function randRangeA(min,max,seed) -> result  { X = new random value: min <= X <= max }
  result := (sh_right((8088405 * seed + 1),8) .and. 0xFFFFFF) mod (max - min + 1) + min
end function { Rand }

function max(a, b) -> return
	return := a*(1 + sh_right(a - b, 31)) - b*sh_right(a - b, 31)
end function

function min(a, b) -> return
	return := a*(1 + sh_right(b - a, 31)) - b*sh_right(b - a, 31)
end function

{ Clamp(X,a,b)  Can be used Inline with the KSE
				Returns the value of X clamped
                between a and b inclusively }
function clamp(X,a,b) -> result  { clamp value of X between a and b }
  result := X*pRange(X,a,b) - a*sh_right(X-a,31) - b*sh_right(b-X,31)
end function

{ pRange(X,a,b) Can be used Inline with the KSE
                This is a conditional predicate version of
                the KSP in_range function and returns
                result = 1 if a <= X <= b
                result = 0 if X < a or X > b }
function pRange(X,a,b) -> result { 1 if a <= X <= b, 0 otherwise }
  result := 1 + (sh_right(b-X,31) .or. sh_right(X-a,31))
end function

// map value v from range [fromX, fromY] to [toX, toY]
function map(v, fromX, fromY, toX, toY) -> return
	return := ((v - fromX) * (toY - toX) / (fromY - fromX)) + toX
end function

// map value v from range [fromX, fromY] to [toX, toY]
function mapInt(v, fromX, fromY, toX, toY) -> return
	return := int((real(v - fromX) * real(toY - toX) / real(fromY - fromX)) + real(toX))
end function

// (from BigBob)
// return_mode chooses the format of the return:
// if return_mode is 0: negative value 0, positive value 1
// if return_mode is 1: negative value -1, positive value 1
function sign(value, return_mode) -> return
	return := ((sh_right(value, 31) .or. 1) + (1-return_mode)) / (2-return_mode)
end function

// convert micro to whole unit
function de_micro(x) -> result
	result := real(x) * 0.000001
end function

// convert milli to whole unit
function de_milli(x) -> result
	result := real(x) * 0.001
end function